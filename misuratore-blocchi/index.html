<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Misuratore Blocchi - Sevcon Tools</title>
  <link rel="icon" type="image/png" href="../logo.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      padding: 20px;
      color: #ffffff;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(26, 26, 46, 0.95);
      backdrop-filter: blur(15px);
      border-radius: 25px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.6);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    header {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: white;
      padding: 25px;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    h1 {
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #ff6b6b, #ffd93d);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 20px;
      padding: 20px;
    }

    .image-section {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      position: relative;
    }

    .controls {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 15px;
      padding: 20px;
      height: fit-content;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: #10b981;
      font-weight: 600;
    }

    .control-group input[type="file"] {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: white;
      cursor: pointer;
    }

    .control-group input[type="number"],
    .control-group input[type="range"] {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: white;
      font-size: 1rem;
    }

    .control-group input[type="range"] {
      padding: 0;
    }

    .control-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      margin-right: 10px;
    }

    .control-group button {
      width: 100%;
      padding: 12px;
      background: rgba(16, 185, 129, 0.2);
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 8px;
      color: #10b981;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .control-group button:hover {
      background: rgba(16, 185, 129, 0.3);
      transform: translateY(-2px);
    }

    .control-group button:active {
      transform: translateY(0);
    }

    .control-group button.active {
      background: rgba(16, 185, 129, 0.4);
    }

    .canvas-container {
      position: relative;
      display: inline-block;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      max-width: 100%;
    }

    #imageCanvas {
      display: block;
      max-width: 100%;
      height: auto;
      cursor: crosshair;
    }

    .point-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #ff6b6b;
      border: 2px solid white;
      border-radius: 50%;
      cursor: move;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .point-handle:hover {
      transform: translate(-50%, -50%) scale(1.5);
    }

    .measurements {
      background: rgba(50, 130, 184, 0.1);
      border: 1px solid rgba(50, 130, 184, 0.3);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      max-height: 400px;
      overflow-y: auto;
    }

    .measurement-item {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 8px;
      border-left: 3px solid #3282b8;
    }

    .measurement-item h4 {
      color: #3282b8;
      margin-bottom: 5px;
      font-size: 0.9rem;
    }

    .measurement-item p {
      color: #bbe1fa;
      font-size: 0.85rem;
      margin: 3px 0;
    }

    .btn-remove {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
      color: #ef4444;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-top: 5px;
    }

    .btn-remove:hover {
      background: rgba(239, 68, 68, 0.3);
    }

    .info-box {
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      color: #ffc107;
    }

    .info-box h3 {
      margin-bottom: 10px;
      font-size: 1rem;
    }

    .info-box ol {
      margin-left: 20px;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    .info-box li {
      margin-bottom: 5px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }

    .range-value {
      display: inline-block;
      margin-left: 10px;
      color: #10b981;
      font-weight: 600;
    }

    @media (max-width: 1024px) {
      .content {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üìè Misuratore Blocchi</h1>
      <p>Carica un'immagine e misura gli elementi usando il quadrato arancione come riferimento</p>
    </header>

    <div class="content">
      <div class="image-section">
        <div class="canvas-container" id="canvasContainer">
          <canvas id="imageCanvas"></canvas>
        </div>
      </div>

      <div class="controls">
        <div class="info-box">
          <h3>üìã Istruzioni</h3>
          <ol>
            <li>Carica l'immagine</li>
            <li>Imposta la dimensione del quadrato arancione (default: 32x32)</li>
            <li><strong>Calibra:</strong> Clicca 4 punti sugli angoli del quadrato arancione</li>
            <li><strong>Misura:</strong> Clicca 4 punti sugli angoli dell'elemento da misurare</li>
            <li>Attiva la griglia per vedere le linee di riferimento</li>
          </ol>
        </div>

        <div class="control-group">
          <label for="imageInput">üì∑ Carica Immagine</label>
          <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="control-group">
          <label for="referenceSize">üìê Dimensione Riferimento (blocchi)</label>
          <input type="number" id="referenceSize" value="32" min="1">
        </div>

        <div class="control-group">
          <button id="calibrateBtn">üéØ Calibra (4 punti sul quadrato arancione)</button>
        </div>

        <div class="control-group">
          <button id="measureBtn">üìè Misura (4 punti sull'elemento)</button>
        </div>

        <div class="control-group">
          <label>
            <div class="checkbox-group">
              <input type="checkbox" id="showGrid">
              <span>Mostra Griglia di Riferimento</span>
            </div>
          </label>
        </div>

        <div class="control-group" id="gridControls" style="display: none;">
          <label for="gridDensity">Densit√† Griglia: <span class="range-value" id="gridDensityValue">5</span></label>
          <input type="range" id="gridDensity" min="1" max="20" value="5">
        </div>

        <div class="control-group">
          <button id="clearBtn">üóëÔ∏è Cancella Tutto</button>
        </div>

        <div class="measurements" id="measurements">
          <h3 style="color: #3282b8; margin-bottom: 15px;">üìä Misure</h3>
          <div id="measurementsList"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const referenceSizeInput = document.getElementById('referenceSize');
    const calibrateBtn = document.getElementById('calibrateBtn');
    const measureBtn = document.getElementById('measureBtn');
    const clearBtn = document.getElementById('clearBtn');
    const measurementsList = document.getElementById('measurementsList');
    const showGrid = document.getElementById('showGrid');
    const gridDensity = document.getElementById('gridDensity');
    const gridDensityValue = document.getElementById('gridDensityValue');
    const gridControls = document.getElementById('gridControls');

    let image = null;
    let isCalibrating = false;
    let isMeasuring = false;
    let currentPoints = [];
    let referenceQuad = null; // {points: [{x,y}, ...], size: number}
    let measurements = [];
    let showGridEnabled = false;

    // Carica immagine
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            image = img;
            canvas.width = img.width;
            canvas.height = img.height;
            redrawCanvas();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    // Calibrazione
    calibrateBtn.addEventListener('click', () => {
      isCalibrating = true;
      isMeasuring = false;
      currentPoints = [];
      calibrateBtn.classList.add('active');
      measureBtn.classList.remove('active');
      canvas.style.cursor = 'crosshair';
    });

    // Misurazione
    measureBtn.addEventListener('click', () => {
      if (!referenceQuad) {
        alert('Prima calibra il quadrato arancione! Clicca su "Calibra" e poi clicca 4 punti sugli angoli del quadrato.');
        return;
      }
      isMeasuring = true;
      isCalibrating = false;
      currentPoints = [];
      measureBtn.classList.add('active');
      calibrateBtn.classList.remove('active');
      canvas.style.cursor = 'crosshair';
    });

    // Griglia
    showGrid.addEventListener('change', () => {
      showGridEnabled = showGrid.checked;
      gridControls.style.display = showGridEnabled ? 'block' : 'none';
      redrawCanvas();
    });

    gridDensity.addEventListener('input', (e) => {
      gridDensityValue.textContent = e.target.value;
      redrawCanvas();
    });

    // Cancella tutto
    clearBtn.addEventListener('click', () => {
      referenceQuad = null;
      measurements = [];
      currentPoints = [];
      measurementsList.innerHTML = '';
      isCalibrating = false;
      isMeasuring = false;
      calibrateBtn.classList.remove('active');
      measureBtn.classList.remove('active');
      canvas.style.cursor = 'default';
      redrawCanvas();
    });

    // Click sul canvas
    canvas.addEventListener('click', (e) => {
      if (!image) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      if (isCalibrating) {
        currentPoints.push({x, y});
        if (currentPoints.length === 4) {
          referenceQuad = {
            points: [...currentPoints],
            size: parseFloat(referenceSizeInput.value)
          };
          isCalibrating = false;
          calibrateBtn.classList.remove('active');
          alert('Calibrazione completata! Ora puoi misurare gli elementi.');
          redrawCanvas();
        } else {
          redrawCanvas();
        }
      } else if (isMeasuring) {
        currentPoints.push({x, y});
        if (currentPoints.length === 4) {
          const measurement = calculateMeasurement(currentPoints);
          measurements.push(measurement);
          addMeasurementToList(measurement);
          currentPoints = [];
          isMeasuring = false;
          measureBtn.classList.remove('active');
          redrawCanvas();
        } else {
          redrawCanvas();
        }
      }
    });

    // Disegna tutto
    function redrawCanvas() {
      if (!image) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
      
      // Disegna griglia se abilitata
      if (showGridEnabled && referenceQuad) {
        drawGrid();
      }
      
      // Disegna riferimento
      if (referenceQuad) {
        drawQuad(referenceQuad.points, '#10b981', 3, true);
        const center = getQuadCenter(referenceQuad.points);
        ctx.fillStyle = '#10b981';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(
          `RIFERIMENTO: ${referenceQuad.size}√ó${referenceQuad.size} blocchi`,
          center.x,
          center.y - 10
        );
        ctx.textAlign = 'left';
      }
      
      // Disegna misure
      measurements.forEach(m => {
        drawQuad(m.points, '#3282b8', 2, false);
        const center = getQuadCenter(m.points);
        ctx.fillStyle = '#3282b8';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(
          `${m.blocksWidth}√ó${m.blocksHeight} blocchi`,
          center.x,
          center.y
        );
        ctx.textAlign = 'left';
      });
      
      // Disegna punti correnti
      if (isCalibrating || isMeasuring) {
        currentPoints.forEach((point, index) => {
          ctx.fillStyle = isCalibrating ? '#10b981' : '#3282b8';
          ctx.beginPath();
          ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Numero del punto
          ctx.fillStyle = 'white';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText((index + 1).toString(), point.x, point.y + 4);
          ctx.textAlign = 'left';
        });
        
        // Disegna linee tra punti
        if (currentPoints.length > 1) {
          ctx.strokeStyle = isCalibrating ? '#10b981' : '#3282b8';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
          for (let i = 1; i < currentPoints.length; i++) {
            ctx.lineTo(currentPoints[i].x, currentPoints[i].y);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
    }

    function drawQuad(points, color, lineWidth, dashed) {
      if (points.length !== 4) return;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      if (dashed) {
        ctx.setLineDash([5, 5]);
      } else {
        ctx.setLineDash([]);
      }
      
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < 4; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function getQuadCenter(points) {
      const x = points.reduce((sum, p) => sum + p.x, 0) / points.length;
      const y = points.reduce((sum, p) => sum + p.y, 0) / points.length;
      return {x, y};
    }

    function calculateMeasurement(points) {
      if (!referenceQuad || points.length !== 4) return null;
      
      // Calcola l'area del quadrilatero di riferimento
      const refArea = calculateQuadArea(referenceQuad.points);
      const refBlocks = referenceQuad.size * referenceQuad.size;
      const pixelsPerBlock = Math.sqrt(refArea / refBlocks);
      
      // Calcola l'area del quadrilatero misurato
      const measArea = calculateQuadArea(points);
      const measBlocks = measArea / (pixelsPerBlock * pixelsPerBlock);
      
      // Calcola dimensioni approssimate (media delle distanze)
      const refWidth = getAverageWidth(referenceQuad.points);
      const refHeight = getAverageHeight(referenceQuad.points);
      const measWidth = getAverageWidth(points);
      const measHeight = getAverageHeight(points);
      
      const blocksWidth = (measWidth / refWidth) * referenceQuad.size;
      const blocksHeight = (measHeight / refHeight) * referenceQuad.size;
      
      return {
        id: Date.now(),
        points: [...points],
        blocksWidth: blocksWidth.toFixed(2),
        blocksHeight: blocksHeight.toFixed(2),
        area: measBlocks.toFixed(2)
      };
    }

    function calculateQuadArea(points) {
      // Formula di Shoelace per l'area di un poligono
      let area = 0;
      for (let i = 0; i < points.length; i++) {
        const j = (i + 1) % points.length;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
      }
      return Math.abs(area) / 2;
    }

    function getAverageWidth(points) {
      const dist1 = distance(points[0], points[1]);
      const dist2 = distance(points[2], points[3]);
      return (dist1 + dist2) / 2;
    }

    function getAverageHeight(points) {
      const dist1 = distance(points[0], points[3]);
      const dist2 = distance(points[1], points[2]);
      return (dist1 + dist2) / 2;
    }

    function distance(p1, p2) {
      return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
    }

    function drawGrid() {
      if (!referenceQuad) return;
      
      const density = parseInt(gridDensity.value);
      const blocksPerLine = referenceQuad.size / density;
      
      // Calcola le trasformazioni per mappare il riferimento distorto
      const refPoints = referenceQuad.points;
      
      ctx.strokeStyle = 'rgba(255, 193, 7, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      
      // Disegna linee orizzontali
      for (let i = 1; i < density; i++) {
        const t = i / density;
        drawGridLine(
          interpolatePoint(refPoints[0], refPoints[3], t),
          interpolatePoint(refPoints[1], refPoints[2], t)
        );
      }
      
      // Disegna linee verticali
      for (let i = 1; i < density; i++) {
        const t = i / density;
        drawGridLine(
          interpolatePoint(refPoints[0], refPoints[1], t),
          interpolatePoint(refPoints[3], refPoints[2], t)
        );
      }
      
      ctx.setLineDash([]);
      
      // Disegna etichette sui bordi
      ctx.fillStyle = 'rgba(255, 193, 7, 0.8)';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      
      // Etichette orizzontali (sinistra)
      for (let i = 0; i <= density; i++) {
        const t = i / density;
        const point = interpolatePoint(refPoints[0], refPoints[3], t);
        ctx.fillText((i * blocksPerLine).toString(), point.x - 15, point.y);
      }
      
      // Etichette verticali (alto)
      for (let i = 0; i <= density; i++) {
        const t = i / density;
        const point = interpolatePoint(refPoints[0], refPoints[1], t);
        ctx.fillText((i * blocksPerLine).toString(), point.x, point.y - 5);
      }
      
      ctx.textAlign = 'left';
    }

    function drawGridLine(p1, p2) {
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    function interpolatePoint(p1, p2, t) {
      return {
        x: p1.x + (p2.x - p1.x) * t,
        y: p1.y + (p2.y - p1.y) * t
      };
    }

    function addMeasurementToList(measurement) {
      const item = document.createElement('div');
      item.className = 'measurement-item';
      item.innerHTML = `
        <h4>Misura #${measurements.length}</h4>
        <p><strong>Larghezza:</strong> ${measurement.blocksWidth} blocchi</p>
        <p><strong>Altezza:</strong> ${measurement.blocksHeight} blocchi</p>
        <p><strong>Area:</strong> ${measurement.area} blocchi¬≤</p>
        <button class="btn-remove" onclick="removeMeasurement(${measurement.id})">Rimuovi</button>
      `;
      measurementsList.appendChild(item);
    }

    function removeMeasurement(id) {
      measurements = measurements.filter(m => m.id !== id);
      redrawCanvas();
      
      // Aggiorna lista
      measurementsList.innerHTML = '';
      measurements.forEach((m, index) => {
        const item = document.createElement('div');
        item.className = 'measurement-item';
        item.innerHTML = `
          <h4>Misura #${index + 1}</h4>
          <p><strong>Larghezza:</strong> ${m.blocksWidth} blocchi</p>
          <p><strong>Altezza:</strong> ${m.blocksHeight} blocchi</p>
          <p><strong>Area:</strong> ${m.area} blocchi¬≤</p>
          <button class="btn-remove" onclick="removeMeasurement(${m.id})">Rimuovi</button>
        `;
        measurementsList.appendChild(item);
      });
    }

    // Esponi funzione globalmente
    window.removeMeasurement = removeMeasurement;
  </script>
</body>
</html>
